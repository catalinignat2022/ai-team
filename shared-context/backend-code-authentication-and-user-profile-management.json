{
  "feature_name": "Authentication and User Profile Management",
  "generated_code": "# Romanian Dating Backend API - Authentication & User Profile Management\n\n## 1. PROJECT STRUCTURE\n\n```\nromanian-dating-backend-api/\nâ”œâ”€â”€ src/\nâ”‚   â”œâ”€â”€ config/\nâ”‚   â”‚   â”œâ”€â”€ database.js\nâ”‚   â”‚   â”œâ”€â”€ jwt.js\nâ”‚   â”‚   â”œâ”€â”€ multer.js\nâ”‚   â”‚   â””â”€â”€ socket.js\nâ”‚   â”œâ”€â”€ controllers/\nâ”‚   â”‚   â”œâ”€â”€ authController.js\nâ”‚   â”‚   â”œâ”€â”€ userController.js\nâ”‚   â”‚   â””â”€â”€ profileController.js\nâ”‚   â”œâ”€â”€ middleware/\nâ”‚   â”‚   â”œâ”€â”€ auth.js\nâ”‚   â”‚   â”œâ”€â”€ validation.js\nâ”‚   â”‚   â”œâ”€â”€ upload.js\nâ”‚   â”‚   â””â”€â”€ errorHandler.js\nâ”‚   â”œâ”€â”€ models/\nâ”‚   â”‚   â”œâ”€â”€ User.js\nâ”‚   â”‚   â”œâ”€â”€ Profile.js\nâ”‚   â”‚   â””â”€â”€ RefreshToken.js\nâ”‚   â”œâ”€â”€ routes/\nâ”‚   â”‚   â”œâ”€â”€ auth.js\nâ”‚   â”‚   â”œâ”€â”€ users.js\nâ”‚   â”‚   â””â”€â”€ profiles.js\nâ”‚   â”œâ”€â”€ services/\nâ”‚   â”‚   â”œâ”€â”€ authService.js\nâ”‚   â”‚   â”œâ”€â”€ userService.js\nâ”‚   â”‚   â”œâ”€â”€ emailService.js\nâ”‚   â”‚   â””â”€â”€ uploadService.js\nâ”‚   â”œâ”€â”€ utils/\nâ”‚   â”‚   â”œâ”€â”€ validators.js\nâ”‚   â”‚   â”œâ”€â”€ helpers.js\nâ”‚   â”‚   â””â”€â”€ constants.js\nâ”‚   â”œâ”€â”€ socket/\nâ”‚   â”‚   â”œâ”€â”€ socketHandler.js\nâ”‚   â”‚   â””â”€â”€ events/\nâ”‚   â”‚       â”œâ”€â”€ userEvents.js\nâ”‚   â”‚       â””â”€â”€ statusEvents.js\nâ”‚   â”œâ”€â”€ tests/\nâ”‚   â”‚   â”œâ”€â”€ auth.test.js\nâ”‚   â”‚   â”œâ”€â”€ user.test.js\nâ”‚   â”‚   â””â”€â”€ profile.test.js\nâ”‚   â”œâ”€â”€ migrations/\nâ”‚   â”‚   â”œâ”€â”€ 001_create_users.js\nâ”‚   â”‚   â”œâ”€â”€ 002_create_profiles.js\nâ”‚   â”‚   â””â”€â”€ 003_create_refresh_tokens.js\nâ”‚   â””â”€â”€ seeds/\nâ”‚       â””â”€â”€ users.js\nâ”œâ”€â”€ uploads/\nâ”‚   â”œâ”€â”€ profiles/\nâ”‚   â””â”€â”€ temp/\nâ”œâ”€â”€ .env.example\nâ”œâ”€â”€ .gitignore\nâ”œâ”€â”€ app.js\nâ”œâ”€â”€ server.js\nâ”œâ”€â”€ package.json\nâ”œâ”€â”€ Dockerfile\nâ”œâ”€â”€ docker-compose.yml\nâ”œâ”€â”€ railway.json\nâ””â”€â”€ README.md\n```\n\n## 2. PACKAGE.JSON\n\n```json\n{\n  \"name\": \"romanian-dating-backend-api\",\n  \"version\": \"1.0.0\",\n  \"description\": \"Backend API for Romanian Dating Platform\",\n  \"main\": \"server.js\",\n  \"scripts\": {\n    \"start\": \"node server.js\",\n    \"dev\": \"nodemon server.js\",\n    \"test\": \"jest --watchAll --no-cache\",\n    \"test:ci\": \"jest --ci --coverage\",\n    \"migrate\": \"node src/migrations/migrate.js\",\n    \"seed\": \"node src/seeds/seed.js\"\n  },\n  \"dependencies\": {\n    \"express\": \"^4.18.2\",\n    \"mongoose\": \"^7.5.0\",\n    \"bcryptjs\": \"^2.4.3\",\n    \"jsonwebtoken\": \"^9.0.2\",\n    \"joi\": \"^17.9.2\",\n    \"multer\": \"^1.4.5-lts.1\",\n    \"cloudinary\": \"^1.40.0\",\n    \"nodemailer\": \"^6.9.4\",\n    \"socket.io\": \"^4.7.2\",\n    \"cors\": \"^2.8.5\",\n    \"helmet\": \"^7.0.0\",\n    \"express-rate-limit\": \"^6.10.0\",\n    \"compression\": \"^1.7.4\",\n    \"morgan\": \"^1.10.0\",\n    \"dotenv\": \"^16.3.1\",\n    \"uuid\": \"^9.0.0\",\n    \"moment\": \"^2.29.4\"\n  },\n  \"devDependencies\": {\n    \"nodemon\": \"^3.0.1\",\n    \"jest\": \"^29.6.2\",\n    \"supertest\": \"^6.3.3\",\n    \"@types/jest\": \"^29.5.4\"\n  },\n  \"engines\": {\n    \"node\": \">=18.0.0\"\n  }\n}\n```\n\n## 3. ENVIRONMENT CONFIGURATION\n\n### .env.example\n```env\n# Server Configuration\nNODE_ENV=development\nPORT=5000\nAPI_URL=http://localhost:5000\n\n# Database\nMONGODB_URI=mongodb://localhost:27017/romanian-dating\nMONGODB_TEST_URI=mongodb://localhost:27017/romanian-dating-test\n\n# JWT Configuration\nJWT_SECRET=your-super-secret-jwt-key-here\nJWT_REFRESH_SECRET=your-super-secret-refresh-key-here\nJWT_EXPIRE=15m\nJWT_REFRESH_EXPIRE=7d\n\n# Email Configuration\nSMTP_HOST=smtp.gmail.com\nSMTP_PORT=587\nSMTP_USER=your-email@gmail.com\nSMTP_PASS=your-app-password\n\n# Cloudinary Configuration\nCLOUDINARY_CLOUD_NAME=your-cloud-name\nCLOUDINARY_API_KEY=your-api-key\nCLOUDINARY_API_SECRET=your-api-secret\n\n# Client URL\nCLIENT_URL=http://localhost:3000\n\n# Rate Limiting\nRATE_LIMIT_WINDOW_MS=900000\nRATE_LIMIT_MAX_REQUESTS=100\n```\n\n## 4. SERVER SETUP\n\n### server.js\n```javascript\nconst app = require('./app');\nconst connectDB = require('./src/config/database');\nconst { createServer } = require('http');\nconst { Server } = require('socket.io');\nconst socketHandler = require('./src/socket/socketHandler');\n\nconst PORT = process.env.PORT || 5000;\n\n// Connect to MongoDB\nconnectDB();\n\n// Create HTTP server\nconst server = createServer(app);\n\n// Initialize Socket.IO\nconst io = new Server(server, {\n  cors: {\n    origin: process.env.CLIENT_URL || \"http://localhost:3000\",\n    methods: [\"GET\", \"POST\"]\n  }\n});\n\n// Handle socket connections\nsocketHandler(io);\n\n// Start server\nserver.listen(PORT, () => {\n  console.log(`ðŸš€ Server running on port ${PORT} in ${process.env.NODE_ENV} mode`);\n});\n\n// Handle unhandled promise rejections\nprocess.on('unhandledRejection', (err) => {\n  console.error('Unhandled Promise Rejection:', err);\n  server.close(() => {\n    process.exit(1);\n  });\n});\n\n// Handle uncaught exceptions\nprocess.on('uncaughtException', (err) => {\n  console.error('Uncaught Exception:', err);\n  process.exit(1);\n});\n\nmodule.exports = server;\n```\n\n### app.js\n```javascript\nconst express = require('express');\nconst cors = require('cors');\nconst helmet = require('helmet');\nconst compression = require('compression');\nconst morgan = require('morgan');\nconst rateLimit = require('express-rate-limit');\nrequire('dotenv').config();\n\nconst errorHandler = require('./src/middleware/errorHandler');\n\n// Import routes\nconst authRoutes = require('./src/routes/auth');\nconst userRoutes = require('./src/routes/users');\nconst profileRoutes = require('./src/routes/profiles');\n\nconst app = express();\n\n// Security middleware\napp.use(helmet());\n\n// CORS configuration\napp.use(cors({\n  origin: process.env.CLIENT_URL || 'http://localhost:3000',\n  credentials: true,\n  methods: ['GET', 'POST', 'PUT', 'DELETE', 'PATCH'],\n  allowedHeaders: ['Content-Type', 'Authorization']\n}));\n\n// Rate limiting\nconst limiter = rateLimit({\n  windowMs: parseInt(process.env.RATE_LIMIT_WINDOW_MS) || 15 * 60 * 1000, // 15 minutes\n  max: parseInt(process.env.RATE_LIMIT_MAX_REQUESTS) || 100,\n  message: {\n    error: 'Prea multe cereri din aceastÄƒ adresÄƒ IP. ÃŽncearcÄƒ din nou mai tÃ¢rziu.'\n  },\n  standardHeaders: true,\n  legacyHeaders: false\n});\n\napp.use('/api/', limiter);\n\n// Body parsing middleware\napp.use(express.json({ limit: '10mb' }));\napp.use(express.urlencoded({ extended: true, limit: '10mb' }));\n\n// Compression middleware\napp.use(compression());\n\n// Logging middleware\nif (process.env.NODE_ENV === 'development') {\n  app.use(morgan('dev'));\n} else {\n  app.use(morgan('combined'));\n}\n\n// Health check endpoint\napp.get('/health', (req, res) => {\n  res.status(200).json({\n    status: 'success',\n    message: 'Server is running',\n    timestamp: new Date().toISOString(),\n    environment: process.env.NODE_ENV\n  });\n});\n\n// API routes\napp.use('/api/auth', authRoutes);\napp.use('/api/users', userRoutes);\napp.use('/api/profiles', profileRoutes);\n\n// Serve uploaded files\napp.use('/uploads', express.static('uploads'));\n\n// 404 handler\napp.use('*', (req, res) => {\n  res.status(404).json({\n    status: 'error',\n    message: `Ruta ${req.originalUrl} nu a fost gÄƒsitÄƒ`\n  });\n});\n\n// Global error handler\napp.use(errorHandler);\n\nmodule.exports = app;\n```\n\n## 5. DATABASE CONFIGURATION\n\n### src/config/database.js\n```javascript\nconst mongoose = require('mongoose');\n\nconst connectDB = async () => {\n  try {\n    const conn = await mongoose.connect(process.env.MONGODB_URI, {\n      useNewUrlParser: true,\n      useUnifiedTopology: true,\n    });\n\n    console.log(`âœ… MongoDB Connected: ${conn.connection.host}`);\n\n    // Handle connection events\n    mongoose.connection.on('error', (err) => {\n      console.error('MongoDB connection error:', err);\n    });\n\n    mongoose.connection.on('disconnected', () => {\n      console.log('MongoDB disconnected');\n    });\n\n    // Graceful shutdown\n    process.on('SIGINT', async () => {\n      await mongoose.connection.close();\n      console.log('MongoDB connection closed through app termination');\n      process.exit(0);\n    });\n\n  } catch (error) {\n    console.error('âŒ MongoDB connection failed:', error.message);\n    process.exit(1);\n  }\n};\n\nmodule.exports = connectDB;\n```\n\n## 6. MODELS\n\n### src/models/User.js\n```javascript\nconst mongoose = require('mongoose');\nconst bcrypt = require('bcryptjs');\nconst jwt = require('jsonwebtoken');\n\nconst userSchema = new mongoose.Schema({\n  email: {\n    type: String,\n    required: [true, 'Email-ul este obligatoriu'],\n    unique: true,\n    lowercase: true,\n    match: [/^\\w+([.-]?\\w+)*@\\w+([.-]?\\w+)*(\\.\\w{2,3})+$/, 'Email invalid']\n  },\n  password: {\n    type: String,\n    required: [true, 'Parola este obligatorie'],\n    minlength: [6, 'Parola trebuie sÄƒ aibÄƒ cel puÈ›in 6 caractere'],\n    select: false\n  },\n  role: {\n    type: String,\n    enum: ['user', 'admin', 'moderator'],\n    default: 'user'\n  },\n  isEmailVerified: {\n    type: Boolean,\n    default: false\n  },\n  emailVerificationToken: String,\n  emailVerificationExpires: Date,\n  passwordResetToken: String,\n  passwordResetExpires: Date,\n  isActive: {\n    type: Boolean,\n    default: true\n  },\n  lastLogin: Date,\n  loginAttempts: {\n    type: Number,\n    default: 0\n  },\n  lockUntil: Date,\n  twoFactorEnabled: {\n    type: Boolean,\n    default: false\n  },\n  twoFactorSecret: String,\n  onlineStatus: {\n    type: String,\n    enum: ['online', 'offline', 'away'],\n    default: 'offline'\n  },\n  lastSeen: {\n    type: Date,\n    default: Date.now\n  }\n}, {\n  timestamps: true,\n  toJSON: { virtuals: true },\n  toObject: { virtuals: true }\n});\n\n// Virtual for user profile\nuserSchema.virtual('profile', {\n  ref: 'Profile',\n  localField: '_id',\n  foreignField: 'user',\n  justOne: true\n});\n\n// Index for performance\nuserSchema.index({ email: 1 });\nuserSchema.index({ isActive: 1 });\nuserSchema.index({ onlineStatus: 1 });\n\n// Virtual for account lock status\nuserSchema.virtual('isLocked').get(function() {\n  return !!(this.lockUntil && this.lockUntil > Date.now());\n});\n\n// Pre-save middleware to hash password\nuserSchema.pre('save', async function(next) {\n  if (!this.isModified('password')) return next();\n  \n  try {\n    const salt = await bcrypt.genSalt(12);\n    this.password = await bcrypt.hash(this.password, salt);\n    next();\n  } catch (error) {\n    next(error);\n  }\n});\n\n// Method to compare password\nuserSchema.methods.comparePassword = async function(candidatePassword) {\n  return await bcrypt.compare(candidatePassword, this.password);\n};\n\n// Method to generate JWT token\nuserSchema.methods.generateAuthToken = function() {\n  return jwt.sign(\n    { \n      id: this._id, \n      email: this.email, \n      role: this.role \n    },\n    process.env.JWT_SECRET,\n    { expiresIn: process.env.JWT_EXPIRE || '15m' }\n  );\n};\n\n// Method to generate refresh token\nuserSchema.methods.generateRefreshToken = function() {\n  return jwt.sign(\n    { id: this._id },\n    process.env.JWT_REFRESH_SECRET,\n    { expiresIn: process.env.JWT_REFRESH_EXPIRE || '7d' }\n  );\n};\n\n// Method to handle failed login attempts\nuserSchema.methods.incLoginAttempts = function() {\n  // If we have a previous lock that has expired, restart at 1\n  if (this.lockUntil && this.lockUntil < Date.now()) {\n    return this.updateOne({\n      $unset: { lockUntil: 1 },\n      $set: { loginAttempts: 1 }\n    });\n  }\n  \n  const updates = { $inc: { loginAttempts: 1 } };\n  \n  // Lock account after 5 failed attempts for 2 hours\n  if (this.loginAttempts + 1 >= 5 && !this.isLocked) {\n    updates.$set = { lockUntil: Date.now() + 2 * 60 * 60 * 1000 }; // 2 hours\n  }\n  \n  return this.updateOne(updates);\n};\n\n// Method to reset login attempts\nuserSchema.methods.resetLoginAttempts = function() {\n  return this.updateOne({\n    $unset: { loginAttempts: 1, lockUntil: 1 }\n  });\n};\n\n// Method to update online status\nuserSchema.methods.updateOnlineStatus = function(status) {\n  this.onlineStatus = status;\n  this.lastSeen = new Date();\n  return this.save();\n};\n\nmodule.exports = mongoose.model('User', userSchema);\n```\n\n### src/models/Profile.js\n```javascript\nconst mongoose = require('mongoose');\n\nconst profileSchema = new mongoose.Schema({\n  user: {\n    type: mongoose.Schema.Types.ObjectId,\n    ref: 'User',\n    required: true,\n    unique: true\n  },\n  firstName: {\n    type: String,\n    required: [true, 'Prenumele este obligatoriu'],\n    trim: true,\n    maxlength: [50, 'Prenumele nu poate avea mai mult de 50 de caractere']\n  },\n  lastName: {\n    type: String,\n    required: [true, 'Numele este obligatoriu'],\n    trim: true,\n    maxlength: [50, 'Numele nu poate avea mai mult de 50 de caractere']\n  },\n  dateOfBirth: {\n    type: Date,\n    required: [true, 'Data naÈ™terii este obligatorie'],\n    validate: {\n      validator: function(date) {\n        const age = Math.floor((new Date() - date) / (365.25 * 24 * 60 * 60 * 1000));\n        return age >= 18 && age <= 100;\n      },\n      message: 'VÃ¢rsta trebuie sÄƒ fie Ã®ntre 18 È™i 100 de ani'\n    }\n  },\n  gender: {\n    type: String,\n    required: [true, 'Genul este obligatoriu'],\n    enum: {\n      values: ['masculin', 'feminin', 'altul'],\n      message: 'Genul trebuie sÄƒ fie masculin, feminin sau altul'\n    }\n  },\n  interestedIn: {\n    type: String,\n    required: [true, 'PreferinÈ›a este obligatorie'],\n    enum: {\n      values: ['masculin', 'feminin', 'ambele'],\n      message: 'PreferinÈ›a trebuie sÄƒ fie masculin, feminin sau",
  "created_at": "2025-09-13T18:27:17.483Z",
  "created_by": "Backend Developer AI"
}